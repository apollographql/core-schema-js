const fs = require('fs')
const path = require('path')
const readdir = require('util').promisify(fs.readdir)
const write = require('util').promisify(fs.writeFile)
const exec = require('util').promisify(require('child_process').exec)

const OUTPUT = path.join(__dirname, 'src', 'errors.ts')

const allErrors = new Map
const allModules = new Map

async function main() {
  for (const file of await readdir(path.join(__dirname, 'dist'))) {
    if (!file.endsWith('.js')) continue
    const modulePath = './' + path.join('dist', path.basename(file, '.js'))
    const sourcePath = './' + modulePath.slice('./dist/'.length)
    const mod = require(modulePath)
    const errors = Object.keys(mod)
      .filter(name => name.startsWith('Err'))
      .map(err => err.slice('Err'.length))

    if (!errors.length) continue

    for (const code of errors) {
      const existing = allErrors.get(code)
      if (existing) {
        throw new Error(`error code ${code} is defined in multiple modules: ${sourcePath} and ${existing}`)
      }
      allErrors.set(code, sourcePath)
    }

    allModules.set(sourcePath, errors)
  }


  const allCodes = [...allErrors.keys()]
  await write(OUTPUT,
`// autogenerated by ../generate-errors.js
// regenerate when new error types are added anywhere in the project.
// to regenerate: npm run build && node ./generate-errors

${[...allModules].map(([path, codes]) =>
  `import { ${codes.map(code => 'Err' + code).join(', ')} } from "${path}"`
).join('\n')}

export type AnyError = ReturnType<${
  allCodes
    .map(code => 'typeof Err' + code)
    .join('|')
}>

const ERROR_CODES = new Set(${JSON.stringify(allCodes)})

export function isAnyError(o: any): o is AnyError {
  return ERROR_CODES.has(o?.code)
}
`)
  await exec(`npx prettier -w "${OUTPUT}"`)
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})